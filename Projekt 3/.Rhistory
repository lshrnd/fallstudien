mseJointAndGrouped = function(modelJaG, data) {
# MSE jointModel (all bio_reps)
mseJoint = mse(data$normed_response,
predict(modelJaG$jointModel))
# MSE groupedModel overall
mseGroupedAll = mse(data$normed_response,
predict(modelJaG$groupedModel))
# MSE groupedModel bio_rep 1
indexBio1 = which(data$bio_rep == 1)
mseBioRep1 = mse(subset(data, bio_rep == 1)$normed_response,
predict(modelJaG$groupedModel)[indexBio1])
# MSE groupedModel bio_rep 2
indexBio2 = which(data$bio_rep == 2)
mseBioRep2 = mse(subset(data, bio_rep == 2)$normed_response,
predict(modelJaG$groupedModel)[indexBio2])
# MSE groupedModel bio_rep 3
indexBio3 = which(data$bio_rep == 3)
mseBioRep3 = mse(subset(data, bio_rep == 3)$normed_response,
predict(modelJaG$groupedModel)[indexBio3])
return(c("mseJoint" = mseJoint,
"mseGroupedAll" = mseGroupedAll,
"mseBioRep1" = mseBioRep1,
"mseBioRep2" = mseBioRep2,
"mseBioRep3" = mseBioRep3))
}
# function - EDjag
# Short:  Calculates ECvalue for Level given by ECval for the joint and
#         the grouped models in modelJaG
#         (should be model like 1 element in the output from jointAndGrouped)
# Input:  modelJaG : list - (like 1 element in the output from jointAndGrouped)
#         ECval : numeric in (0, 100) -  the ECvalue to be predicted
# Output: vector containing the predictions (first element for joint,
#                                            the rest for the bio_reps)
EDjag = function(modelJaG, ECval, ...) {
c(ED(modelJaG$jointModel, ECval, display = FALSE, ...)[1],
ED(modelJaG$groupedModel, ECval, display = FALSE, ...)[1:3])
}
# function - coefOneModel
# Short:  Creates a matrix with all coefficents for one model type
#         containing the coefs for the joint and the grouped models (single bio_reps)
# Input:  modelJaG - (like 1 element in the output from jointAndGrouped)
# Output: see Short
coefOneModel = function(modelJaG) {
jointCoef = modelJaG$jointModel$coefficients
coefMat = matrix(NA, nrow = 4, ncol = length(jointCoef))
coefMat[1, ] = modelJaG$jointModel$coefficients
coefMat[2:4, ] = modelJaG$groupedModel$coefficients
rownames(coefMat) = c("joint", "bio_rep1", "bio_rep2", "bio_rep3")
colnames(coefMat) = names(jointCoef)
return(coefMat)
}
# function EC20comp
# Short:  Calculates for a model the response value for the former EC20 and
#         the new EC20
EC20respComp = function(model) {
ec20 = ED(model, 20, display = FALSE)
newEC20resp = predict(model, ec20)
oldEC20resp = predict(model, data.frame(1))
return(c("newEC20resp" = newEC20resp, "oldEC20resp" = oldEC20resp))
}
##### Mix 2 #####
mix2 = subset(single, mix_number == 2)
### Fit Models
# fit all models for joint bio_reps and single bio_reps
mix2models = list(rep(NA, 9))
i = 0
for(model in models) {
i = i + 1
mix2models[[i]] = jointAndGrouped(model, mix2, main = paste("mix2 : ", model$name))
names(mix2models)[i] = model$name
}
# print all models
mix2models
# -> for BC f almost always < 0 -> probably not sensible to assume hormesis
# -> Weibull type 2 looking good
### Coefficients
# all model coefficients for all models
mix2allCoefs = sapply(mix2models, coefOneModel)
mix2allCoefs
# TODO: extract coefs for joint models, put them in one cool table or sth
#mix2jointCoefs = as.data.frame(matrix(NA, nrow = 8, ncol = 5))
#rownames(mix2jointCoefs) = modelNames
#colnames(mix2jointCoefs) = names(mix2allCoefs$BC.5[1, ])
#mix2allCoefs$BC.5[1, ]
#mix2allCoefs[[1]][1, ]
### MSE
# calculate all MSEs
mseMatMix2 = t(sapply(mix2models, mseJointAndGrouped, data = mix2))
mseMatMix2
# -> LL2 much worse again
### EC20s
# calculate all EC20s (except BC.4, BC.5)
EC20mat = sapply(mix2models[(-5):(-4)], EDjag, ECval = 20)
rownames(EC20mat) = c("EC20joint", "EC20bio_rep1", "EC20bio_rep2", "EC20bio_rep3")
# print EC20s
t(EC20mat)
# -> new EC20 estimate much smaller than the old one
### Compare Response at former and new EC20
EC20respMat = matrix(NA, ncol = 2, nrow = 7)
colnames(EC20respMat) = c("newEC20resp", "oldEC20resp")
rownames(EC20respMat) = modelNames[(-5):(-4)]
i = 0
for(model in mix2models[(-5):(-4)]) {
i = i + 1
EC20respMat[i, ] = EC20respComp(model$jointModel)
}
EC20respMat
# -> new EC20 response much higher than the one for the former EC20
### Plots
# extracts a jointModel from the JaG and plots it
helper = function(modelJaG, ...) {
plot(modelJaG$jointModel, ...)
}
# All joint Models
plot(mix2models$LL.4$jointModel)
mapply(helper,
mix2models,
col = c("black", "red", "blue", "green", "orange", "purple", "yellow", "magenta"),
MoreArgs = list(add = TRUE, type = "none"))
#### Mix 3 #####
mix3 = subset(single, mix_number == 3)
### Fit Models
# fit all models for joint bio_reps and single bio_reps
mix3models = list(rep(NA, 9))
i = 0
for(model in models) {
i = i + 1
mix3models[[i]] = jointAndGrouped(model, mix3, main = paste("mix3 : ", model$name))
names(mix3models)[i] = model$name
}
### Coefficients
# all model coefficients for all models
mix3allCoefs = sapply(mix3models, coefOneModel)
mix3allCoefs
### MSE
# calculate all MSEs
mseMatMix3 = t(sapply(mix3models, mseJointAndGrouped, data = mix3))
mseMatMix3
# -> Weibull type 1 models looking good
### EC20s
# calculate all EC20s (except BC.4, BC.5)
mix3EC20mat = sapply(mix3models[(-5):(-4)], EDjag, ECval = 20)
rownames(mix3EC20mat) = c("EC20joint", "EC20bio_rep1", "EC20bio_rep2", "EC20bio_rep3")
# print EC20s
t(mix3EC20mat)
# -> new EC20 estimate much smaller than the old one
### Coefficients
# all model coefficients for all models
mix3allCoefs = sapply(mix3models, coefOneModel)
mix3allCoefs
### Compare Response at former and new EC20
mix3EC20respMat = matrix(NA, ncol = 2, nrow = 7)
colnames(mix3EC20respMat) = c("newEC20resp", "oldEC20resp")
rownames(mix3EC20respMat) = modelNames[(-5):(-4)]
i = 0
for(model in mix3models[(-5):(-4)]) {
i = i + 1
mix3EC20respMat[i, ] = EC20respComp(model$jointModel)
}
mix3EC20respMat
# -> response value at new EC20 estimate much higher than the response at the old one
#### Mix 4 #####
mix4 = subset(single, mix_number == 4)
### Fit Models
# fit all models for joint bio_reps and single bio_reps
mix4models = list(rep(NA, 9))
i = 0
for(model in models) {
i = i + 1
mix4models[[i]] = jointAndGrouped(model, mix4, main = paste("mix4 : ", model$name))
names(mix4models)[i] = model$name
}
### MSE
# calculate all MSEs
mseMatMix4 = t(sapply(mix4models, mseJointAndGrouped, data = mix4))
mseMatMix4
### EC20s
# calculate all EC20s (except BC.4, BC.5)
mix4EC20mat = sapply(mix4models[(-5):(-4)], EDjag, ECval = 20)
rownames(mix4EC20mat) = c("EC20joint", "EC20bio_rep1", "EC20bio_rep2", "EC20bio_rep3")
# print EC20s
t(mix4EC20mat)
# TODO: EC20 for BC models ?
#ED(mix4models$BC.4$jointModel, 0.8, bound = FALSE)
#ED(mix4models$BC.4$jointModel, 20, bound = FALSE, type = "rel")
### Compare Response at former and new EC20
mix4EC20respMat = matrix(NA, ncol = 2, nrow = 7)
colnames(mix4EC20respMat) = c("newEC20resp", "oldEC20resp")
rownames(mix4EC20respMat) = modelNames[(-5):(-4)]
i = 0
for(model in mix4models[(-5):(-4)]) {
i = i + 1
mix4EC20respMat[i, ] = EC20respComp(model$jointModel)
}
mix4EC20respMat
#### Mix 5 #####
mix5 = subset(single, mix_number == 5)
?ED
knitr::opts_chunk$set(echo = TRUE)
# set working directory
setwd("C:/Users/jorri/Documents/TU Dortmund/WiSe 2024-25/HiWi/5erSet")
{
# load packages
library(MASS)
library(drc)
library(readxl)
}
?ED
# define general funs
# mse
mse = function(observed, prediction) {
n = length(observed)
sum( ((observed - prediction))^2 / n )
}
# define general variables
# list of models of interest
models = list(LL.4(), LL.3(), LL.2(), BC.5(), BC.4(), W1.4(), W1.3(), W2.4(), W2.3())
modelNames = c("LL.4", "LL.3", "LL.2", "BC.5", "BC.4", "W1.4", "W1.3", "W2.4", "W2.3")
# former EC20s
Substance_EC20s = c("A" = 0.0251925,
"B" = 0.219149,
"c" = 0.025283,
"D" = 0.000009,
"E" = 0.117768)
# mix percentages : conc = this * formerEC20
x1er_mix_pct = c(0,
0.0390625,
0.078125,
0.15625,
0.3125,
0.625,
1.25,
2.5,
5,
10)
# read data
x5er_data =  read_excel("5er_data.xlsx")
x5er_data = x5er_data[,1:13]
x5er_1er_mix = x5er_data[1:45,]
# transform data
single = data.frame("mix_number" = x5er_1er_mix$`mix number`,
"bio_rep" = x5er_1er_mix$`biological replicate`,
"tech_rep" = x5er_1er_mix$`technical replicate`,
"conc" = rep(x1er_mix_pct, each = 45),
"response" =
c(x5er_1er_mix$Ctrl,
x5er_1er_mix$C1,
x5er_1er_mix$C2,
x5er_1er_mix$C3,
x5er_1er_mix$C4,
x5er_1er_mix$C5,
x5er_1er_mix$C6,
x5er_1er_mix$C7,
x5er_1er_mix$C8,
x5er_1er_mix$C9))
# Function to calculate means for control values for each technical replicate
# (of each biological replicate)
meansPerBioRep = function(number){
tapply(subset(single, mix_number == number & conc == 0)$response,
subset(single, mix_number == number & conc == 0)$bio_rep,
mean)
}
# Normalize all Response values by the means of the control of their technical
# replicate and add this to dataSet
means = as.vector(sapply(1:5,meansPerBioRep))
meansV = rep(means, each = 3, times = 10)
single = cbind(single, "normed_response" = single$response/meansV)
# function jointAndGrouped
# Short:  fits a joint and a grouped (by bio_rep) model (fct) for data for:
#           normed_response ~ conc
#
# Input:  data : data.frame - subset of single to fit a joint and a grouped model
#                           (by bio_rep) for of type fct
#         fct : function - the drm that is to be fitted (default LL.4())
#         ... - for graphical params to plot (only of groupedModel)
# Output: list - of jointModel and groupedModel
#         plot of joint and groupedModel curves with all points
jointAndGrouped = function(fct = LL.4(), data, ...) {
# joint fct (all bio_reps together)
jointModel = drm(normed_response ~ conc,
data = data,
fct = fct)
# grouped model (single bio_reps)
groupedModel = drm(normed_response ~ conc,
curveid = bio_rep,
data = data,
fct = fct)
plot(groupedModel,
type = "all",
broken = TRUE,
...)
plot(jointModel,
type = "none",
add = TRUE,
lwd = 2,
broken = TRUE)
return(list("jointModel" = jointModel, "groupedModel" = groupedModel))
}
# function mseJointAndGrouped
# Short:  Calculates the MSE for
#
# Input:  modelJaG : List containing a joint and a grouped drm,
#                    (1 element of the output) from function "jointAndGrouped"
#         data : dataframe - the subset (of single) this model is trained on
# Output: a named vector containing the MSEs
mseJointAndGrouped = function(modelJaG, data) {
# MSE jointModel (all bio_reps)
mseJoint = mse(data$normed_response,
predict(modelJaG$jointModel))
# MSE groupedModel overall
mseGroupedAll = mse(data$normed_response,
predict(modelJaG$groupedModel))
# MSE groupedModel bio_rep 1
indexBio1 = which(data$bio_rep == 1)
mseBioRep1 = mse(subset(data, bio_rep == 1)$normed_response,
predict(modelJaG$groupedModel)[indexBio1])
# MSE groupedModel bio_rep 2
indexBio2 = which(data$bio_rep == 2)
mseBioRep2 = mse(subset(data, bio_rep == 2)$normed_response,
predict(modelJaG$groupedModel)[indexBio2])
# MSE groupedModel bio_rep 3
indexBio3 = which(data$bio_rep == 3)
mseBioRep3 = mse(subset(data, bio_rep == 3)$normed_response,
predict(modelJaG$groupedModel)[indexBio3])
return(c("mseJoint" = mseJoint,
"mseGroupedAll" = mseGroupedAll,
"mseBioRep1" = mseBioRep1,
"mseBioRep2" = mseBioRep2,
"mseBioRep3" = mseBioRep3))
}
# function - EDjag
# Short:  Calculates ECvalue for Level given by ECval for the joint and
#         the grouped models in modelJaG
#         (should be model like 1 element in the output from jointAndGrouped)
# Input:  modelJaG : list - (like 1 element in the output from jointAndGrouped)
#         ECval : numeric in (0, 100) -  the ECvalue to be predicted
# Output: vector containing the predictions (first element for joint,
#                                            the rest for the bio_reps)
EDjag = function(modelJaG, ECval, ...) {
c(ED(modelJaG$jointModel, ECval, display = FALSE, ...)[1],
ED(modelJaG$groupedModel, ECval, display = FALSE, ...)[1:3])
}
# function - coefOneModel
# Short:  Creates a matrix with all coefficents for one model type
#         containing the coefs for the joint and the grouped models (single bio_reps)
# Input:  modelJaG - (like 1 element in the output from jointAndGrouped)
# Output: see Short
coefOneModel = function(modelJaG) {
jointCoef = modelJaG$jointModel$coefficients
coefMat = matrix(NA, nrow = 4, ncol = length(jointCoef))
coefMat[1, ] = modelJaG$jointModel$coefficients
coefMat[2:4, ] = modelJaG$groupedModel$coefficients
rownames(coefMat) = c("joint", "bio_rep1", "bio_rep2", "bio_rep3")
colnames(coefMat) = names(jointCoef)
return(coefMat)
}
# function EC20comp
# Short:  Calculates for a model the response value for the former EC20 and
#         the new EC20
EC20respComp = function(model) {
ec20 = ED(model, 20, display = FALSE)
newEC20resp = predict(model, ec20)
oldEC20resp = predict(model, data.frame(1))
return(c("newEC20resp" = newEC20resp, "oldEC20resp" = oldEC20resp))
}
##### Mix 1 #####
mix1 = subset(single, mix_number == 1)
### Fit Models
# fit all models for joint bio_reps and single bio_reps & plot them
mix1models = list(rep(NA, 8))
i = 0
for(model in models) {
i = i + 1
mix1models[[i]] = jointAndGrouped(model, mix1, main = paste("mix1 : ", model$name))
names(mix1models)[i] = model$name
}
#### Mix 5 #####
mix5 = subset(single, mix_number == 5)
### Fit Models
# fit all models for joint bio_reps and single bio_reps
mix5models = list(rep(NA, 9))
i = 0
for(model in models) {
i = i + 1
mix5models[[i]] = jointAndGrouped(model, mix5, main = paste("mix5 : ", model$name))
names(mix5models)[i] = model$name
}
### Coefficients
# all model coefficients for all models
mix5allCoefs = sapply(mix5models, coefOneModel)
mix5allCoefs
### MSE
# calculate all MSEs
mseMatMix5 = t(sapply(mix5models, mseJointAndGrouped, data = mix5))
mseMatMix5
### EC20s
# calculate all EC20s (except BC.4, BC.5)
mix5EC20mat = sapply(mix5models[(-5):(-4)], EDjag, ECval = 20)
rownames(mix5EC20mat) = c("EC20joint", "EC20bio_rep1", "EC20bio_rep2", "EC20bio_rep3")
# print EC20s
t(mix5EC20mat)
### Compare Response at former and new EC20
mix5EC20respMat = matrix(NA, ncol = 2, nrow = 7)
colnames(mix5EC20respMat) = c("newEC20resp", "oldEC20resp")
rownames(mix5EC20respMat) = modelNames[(-5):(-4)]
i = 0
for(model in mix5models[(-5):(-4)]) {
i = i + 1
mix5EC20respMat[i, ] = EC20respComp(model$jointModel)
}
mix5EC20respMat
# Test -  to show that it makes no difference to the model fit using the true
#         concentration or only the mmultiplier for the old EC20
# joint model
realConc = mix5$conc * Substance_EC20s[5]
mix5LL.4jointTrueConc = drm(normed_response ~ realConc,
data = mix5,
fct = LL.4())
mix5LL.4jointTrueConc
mix5models$LL.4$jointModel
# All the same, but e (only moved via the multiplicative constant Substance_EC20s[5])
plot(mix5LL.4jointTrueConc)
plot(mix5models$LL.4$jointModel)
mse(mix5$normed_response, predict(mix5LL.4jointTrueConc))
mseMatMix5
# grouped model
mix5LL.4groupedTrueConc = drm(normed_response ~ realConc,
curveid = bio_rep,
data = mix5,
fct = LL.4())
mix5LL.4groupedTrueConc
mix5models$LL.4$groupedModel
# All the same, but e (only moved via the multiplicative constant Substance_EC20s[5])
plot(mix5LL.4groupedTrueConc)
plot(mix5models$LL.4$groupedModel)
mse(mix5$normed_response, predict(mix5LL.4groupedTrueConc))
mseMatMix5
mseMatMix5
?println
library(DescTools)
library(MASS)
setwd("C:/Users/jorri/Documents/GitHub/fallstudien/Projekt 3")
dataTable = read.table("Kuckuckseier.txt", header = TRUE)
dataTable
WP = dataTable$WP
BP = dataTable$BP[1:15]
RK = dataTable$RK[1:16]
ZK = dataTable$ZK[1:15]
data = data.frame(c(WP, BP, RK, ZK), c(rep("WP", 45),
rep("BP", 15),
rep("RK", 16),
rep("ZK", 15)))
names(data) = c("eggLength", "hostBird")
hist(WP,
xlim = c(19,25))
hist(BP,
xlim = c(19,25))
hist(RK,
xlim = c(19,25))
hist(ZK,
xlim = c(19,25))
qqnorm(WP)
qqnorm(BP)
qqnorm(RK)
qqnorm(ZK)
# H12 : mu(WP) = mu(BP)
t.test(WP, BP)
# H13 : mu(WP) = mu(RK)
t.test(WP, RK)
# H14 : mu(WP) = mu(ZK)
t.test(WP, ZK)
# H23 : mu(BP) = mu(RK)
t.test(BP, RK)
# H24 : mu(BP) = mu(ZK)
t.test(BP, ZK)
# H34 : mu(RK) = mu(ZK)
t.test(RK, ZK)
# H1234
aovH1234 = aov(eggLength ~ hostBird, data = data)
summary(aovH1234)
# H123
aovH123 = aov(eggLength ~ hostBird, data = subset(data, data$hostBird != "ZK"))
summary(aovH123)
# H124
aovH124 = aov(eggLength ~ hostBird, data = subset(data, data$hostBird != "RK"))
summary(aovH124)
# H134
aovH134 = aov(eggLength ~ hostBird, data = subset(data, data$hostBird != "BP"))
summary(aovH134)
# H234
aovH234 = aov(eggLength ~ hostBird, data = subset(data, data$hostBird != "WP"))
summary(aovH234)
# H1234
aovH1234 = aov(eggLength ~ hostBird, data = data)
summary(aovH1234)
ScheffeTest(aovH1234)
### Leite mit Scheffe Methode (simultane KIs z.N. alpha her)
alpha = 0.05
y = data$eggLength
# Designmatrix
X = matrix(0, nrow = 91, ncol = 4)
X[1:45, 1] = 1
X[46:60, 2] = 1
X[61:76, 3] = 1
X[77:91, 4] = 1
#X = X[, 2:5]
X
n = length(X[ , 1])
p = length(X[1, ])
?stripchart
stripchart(WP)
stripchart(WP, vertical = TRUE)
